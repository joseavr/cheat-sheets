# üå∂Ô∏è Flask Routes
Class: <a href=""> </a>

Subject: [[Flask/README]]

Date: 2023-03-23

Topics: #, #, # 

---

# üé¨ Intro to Routes
- Routes are used to map URLs to functions that handle requests from clients. 
- In other words, a route specifies a URL and associates it with a function that will be called when the server receives a request that matches that pattern. The function then generates a response that is returned to the client.

```python
# These are different routes
@app.route('/home')
@app.route('/account')
@app.route('/login')
@app.route('/user/user-1')
```

# üéñÔ∏è Decorators
- A special type of function that modifies the behavior of another function. 
- Used to associate a function with a route.
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')  # decorator
def hello(): 
    return 'Hello, World!'
```
- In this example, the `@app.route('/')` decorator specifies that the `hello()` function should handle requests for the root URL (i.e., '/'). 
- When a client sends a GET request to the root URL, Flask will call the `hello()` function, which returns the string 'Hello, World!' as a response.
	- Oftenly returns a HTML template.

## Decorators with Parameters
```python
@app.route('/user/<name>') # decorator
def user(name):
    return f'Hello, {name}!'
```
- Decorator specifies that the `user()` function should handle requests for URLs that match the pattern `/user/<name>`
- Angle brackets indicate a variable part of the URL. Variable will be passed as an argument to the function

# üëÄ View Function
- Associates function to a route. 
- Specifies what things to do when user enters to a route
- A view function is responsible for handling requests and generating responses.
- The response generated by a view function can take different forms, such as HTML pages, JSON data, or images.
```python
@app.route('/')
def hello():  # view function
    return 'Hello, World!'
```

# üìù Render Template
- Rendering a template means returning HTML pages when accessing a route.
- Suppose we have the following template
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Products</title>
  </head>
  <body>
    <h1>Products</h1>
    <ul>
      {% for product in products %}
        <li>{{ product.name }} - {{ product.price }}</li>
      {% endfor %}
    </ul>
  </body>
</html>
```

- To render this template in a view function,
	- Load the template using a template engine such as Jinja2. 
	- Pass the data to be displayed (in this case, a list of products) to the template engine, which would fill in the placeholders and return the resulting HTML as the response.
- Render template takes two arguments:
	- `render_template(HTML , variables)`
	- The HTML template to be rendered when the route is accessed.
	- The variables from the view functions that will be passed to the HTML template
```python
@app.route('/products')
def products():
    products = [
        {'name': 'Product 1', 'price': 10.0},
        {'name': 'Product 2', 'price': 20.0},
        {'name': 'Product 3', 'price': 30.0},
    ]
    return render_template('products.html', products=products)
```

# ‚û°Ô∏è Redirect 
- Redirecting means sending the user's browser to a different URL.
- Often used after a form submission, to redirect the user to a different page after their data has been processed.
```python
@app.route('/add_product', methods=['POST'])
def add_product():
    # Process the form data and add the product to the database
    # ...
    # Redirect to the products page
    return redirect(url_for('products'))
```

- There also can be `render_template()` and `redirect()` at the same time
	- Render template to render the page when route is accessed
	- Redirect to send user another page after a form submitted
```python
from flask import Flask, redirect, request, url_for

app = Flask(__name__)

@app.route('/login', methods=['POST'])
def login():
    # Process the form data to login account
    # If success
	    redirect(url_for('account'))
	# If fail
		redirect(url_for('login'))
    # Render login.html page
    return render_template('login.html')
```

## `url_for`
- A function that generates a URL for a view function.
- Useful for no hardcoding URLs 
- **Rule**: `url_for('<view_function>', '<variable=data>')`
	- Two parameters:
	- `<view_function>`: the view function itself without `()`
	- `<variable=data>`: variables that takes the route. `variable`'s name must be same as in the route and `data` any data passing to the variable 

- Example
```html
<!-- Account.html -->
<a href="{{ url_for('user_detail', username=current_user.username) }}">
</a>
```

```python
# User Detail Route
@app.route("/user/<username>")
def user_detail(username):
  # Retrieve user from database
  return render_template(...) # Renders user_detail.html
```

# How to 

## Multiple routes for a function
```python
@app.route('/foo')
@app.route('/bar')
def foobar():
    return 'This is the foobar page.'
```

## Multiple functions for a route
```python
@app.route('/foobar')
def foobar():
    return render_template('foobar.html')

@app.route('/foobar', methods=['POST'])
def handle_foobar_form():
    # code to handle the submitted form data
    return redirect('/foobar')
```
- The first function, `foobar`, is called when the user navigates to the `/foobar` URL. 
	- Returns a rendered HTML template, which might contain a form that the user can fill out.
- The second function is called when the user submits the form on the `/foobar` page. 
	- Handles the submitted form data and returns a redirect to the same `/foobar` URL, which causes the `foobar` function to be called again and the updated content to be displayed.
- **Note**: that we have specified the `methods=['POST']` argument for the second `@app.route` decorator. 
	- This tells Flask to only call this function when a POST request is made to the `/foobar` URL. 
	- By default, Flask assumes that routes will only handle GET requests, so you need to specify `methods=['POST']` if you want to handle other HTTP methods like POST, PUT, DELETE, etc.